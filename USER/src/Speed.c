
#include "headfile.h"

/**********全局变量定义********/
int32 LeftDead = 400;
int32 RighDead = 430;               //左右电机死区：320
float Ratio_Encoder_Left = 50/(1175*0.02);//  原50 8.8 左轮速度=counter*左轮周长(mm)/(左轮转一圈对应的脉冲数*程序周期)
float Ratio_Encoder_Righ = 50/(1175*0.02);// 右轮速度=counter*右轮周长(mm)/(右轮转一圈对应的脉冲数*程序周期)
float g_fRealSpeed = 0;				//真实速度
float g_fLeftRealSpeed;
float g_fRighRealSpeed;
float g_fSpeedFilter = 0;                //阶梯滤波速度
float g_fExpectSpeed;              //期望速度,未转换成真实速度，但线性相关	
float g_fSpeedError;		        //速度偏差
float g_fSpeedErrorTemp[5] = {0};
float fSpeedErrorInteg = 0;
int32 g_nLeftpulse = 0,g_nRighpulse = 0;
float g_PWMOut;
int32 g_nLeftPWM, g_nRighPWM;
int8 fast_flag=0;

float g_FastSpeed = 1400;//直道加速（测试中）最高1400

//速度控制
float g_speedControl_P = 160;		//速度P160
float g_speedControl_I = 120;		//速度I120
float g_fSpeedControlOut = 0;		//速度输出
int   g_fmaxspeed = 9000;               //速度限幅


  int32 nLeftPWM = 0, nRighPWM = 0;//左右电机pwm输出
  
void PWMOut(void)
{
   
    if(Flag_Speed == OFF)      g_fSpeedControlOut = 0;	//如果Flag_Speed == OFF     不输出速度
    if(Flag_Direction == OFF)  g_fDirectionControlOut = 0;//如果Flag_Direction == OFF 不输出方向
  
  if(flag_go!=1)
    {
      g_nLeftPWM = (int32)(g_fSpeedControlOut - g_fDirectionControlOut);
      g_nRighPWM = (int32)(g_fSpeedControlOut + g_fDirectionControlOut); 
    } 
	//g_nLeftPWM = g_nLeftPWM;//电机差异补偿
	//g_nRighPWM = g_nRighPWM*1.05;
  
  if(Flag_Stop == OFF) 				//如果Flag_Stop == OFF电机输出0
    {
  	g_nLeftPWM = 0;g_nRighPWM = 0;
     }

    	if(g_nLeftPWM < 0)
	{
		nLeftPWM = LeftDead - g_nLeftPWM;
		nLeftPWM = (nLeftPWM > g_fmaxspeed? g_fmaxspeed: nLeftPWM);
                
		ctimer_pwm_duty(TIMER2_PWMCH0_B5, 0);        //左正
		ctimer_pwm_duty(TIMER2_PWMCH1_B4, nLeftPWM);//左反
	}
	else
	{
		nLeftPWM = LeftDead + g_nLeftPWM;
		nLeftPWM = (nLeftPWM > g_fmaxspeed? g_fmaxspeed: nLeftPWM);
		ctimer_pwm_duty(TIMER2_PWMCH0_B5, nLeftPWM); //左正
		ctimer_pwm_duty(TIMER2_PWMCH1_B4, 0);         //左反
	}

	if(g_nRighPWM < 0)
	{
		nRighPWM = RighDead - g_nRighPWM;
		nRighPWM = (nRighPWM > g_fmaxspeed? g_fmaxspeed: nRighPWM);
		ctimer_pwm_duty(TIMER1_PWMCH0_A18, 0);       //右正
		ctimer_pwm_duty(TIMER1_PWMCH1_A20, nRighPWM); //右反
	}        
	else
	{
		nRighPWM = RighDead + g_nRighPWM;
		nRighPWM = (nRighPWM > g_fmaxspeed? g_fmaxspeed: nRighPWM);
		ctimer_pwm_duty(TIMER1_PWMCH0_A18, nRighPWM);//右正
		ctimer_pwm_duty(TIMER1_PWMCH1_A20, 0);       //右反
	}
}
/************************************************
 * @file	     计算速度偏差
 * @note      	产生全局变量g_fSpeedError
 * @date		2020
 ************************************************/
void CalSpeedError(void)
{
	static float fSpeedOld = 0, fSpeedNew = 0;
	
	g_nLeftpulse = (gpio_get(Coder_dir_left) == 1? ctimer_count_read(TIMER0_COUNT1_A2):-ctimer_count_read(TIMER0_COUNT1_A2));//读取左轮脉冲
	ctimer_count_clean(TIMER0_COUNT1_A2);
	g_nRighpulse = (gpio_get(Coder_dir_right) == 0? ctimer_count_read(TIMER3_COUNT0_A4):-ctimer_count_read(TIMER3_COUNT0_A4));//读取右轮脉冲
	ctimer_count_clean(TIMER3_COUNT0_A4);	
	
	g_fLeftRealSpeed = g_nLeftpulse*Ratio_Encoder_Left;
	g_fLeftRealSpeed = (g_fLeftRealSpeed>3400?3400:g_fLeftRealSpeed);//滤左编码器的噪声
	g_fRighRealSpeed = g_nRighpulse*Ratio_Encoder_Righ;
	g_fRighRealSpeed = (g_fRighRealSpeed>3400?3400:g_fRighRealSpeed);//滤右编码器的噪声
	
	g_fRealSpeed = (g_fLeftRealSpeed + g_fRighRealSpeed) * 0.5;//真实速度
	
	//速度采集梯度平滑，每次采集最大变化200
	fSpeedOld = g_fSpeedFilter;
	fSpeedNew = g_fRealSpeed;
	
	if(fSpeedNew>=fSpeedOld)
		g_fSpeedFilter = ((fSpeedNew-fSpeedOld)>300?(fSpeedOld+300):fSpeedNew);
	else
		g_fSpeedFilter = ((fSpeedNew-fSpeedOld)<-300?(fSpeedOld-300):fSpeedNew);
        
        //速度变化
        
        if(g_ValueOfADError <= 170 && stop_flag == 0 && slow_flag==0)
        {
              g_fExpectSpeed = g_FastSpeed;     //直道速度
              fast_flag=1;
        }
        else if(g_ValueOfADError > 170 && g_ValueOfADError<=400 && stop_flag==0 && slow_flag==0)
        {
              g_fExpectSpeed = (g_FastSpeed+eeprom_exspeed)*0.5;         
        }
        else if(slow_flag==1)
        { 
              g_fExpectSpeed = 280;
              fast_flag=0;
        }
        else if(slow_flag==1 && g_stopFlag==14)
        
              g_fExpectSpeed = 0;
       /*   
        else if(stop_time>1 && stop_flag==1) //减速停车后传球
        {
              g_fExpectSpeed = 0;
        }
       */
        else
        {
              g_fExpectSpeed = eeprom_exspeed;
              fast_flag=0;
        }
        
	g_fSpeedError =  g_fExpectSpeed - g_fRealSpeed;
	g_fSpeedErrorTemp[4] = g_fSpeedErrorTemp[3];
	g_fSpeedErrorTemp[3] = g_fSpeedErrorTemp[2];
	g_fSpeedErrorTemp[2] = g_fSpeedErrorTemp[1];
	g_fSpeedErrorTemp[1] = g_fSpeedErrorTemp[0];
	g_fSpeedErrorTemp[0] = g_fSpeedError;
	
}

/**
 * @file	  速度控制
 * @note      	速度梯度平滑
 * @date	   2020
 */
void SpeedControl(void)
{
	int8 index=1;

	CalSpeedError();	//计算速度偏差
        
	g_fSpeedError = (g_fSpeedError>800?800:g_fSpeedError);//速度偏差限幅
        
	//EEPROM中参数
	//g_speedControl_P = EEPROM_READ_WORD(12);	//320
	//g_speedControl_I = EEPROM_READ_WORD(16);	//100
	
	//积分分离
	if((g_fSpeedError<=300)&&(g_fSpeedError>=-300))
	index=1;
	else
	index=0;	
	fSpeedErrorInteg = index * g_speedControl_I * g_fSpeedError * 0.00001;
         /*	
	if(Flag_Stop==OFF|Flag_Speed==OFF)
	{
		fSpeedErrorInteg = 0;	//停车积分清零
	}
         */	
	//fSpeedErrorInteg = (fSpeedErrorInteg < 0.0? 0.0: fSpeedErrorInteg);//积分下限
	//fSpeedErrorInteg = (fSpeedErrorInteg > 400.0? 400.0: fSpeedErrorInteg);//积分上限
	//速度控制算法（增量式PI）
	g_fSpeedControlOut += g_speedControl_P*0.04*(g_fSpeedErrorTemp[0]-g_fSpeedErrorTemp[1]) + fSpeedErrorInteg;
	g_fSpeedControlOut = (g_fSpeedControlOut>=9000?9000:g_fSpeedControlOut);
	
}